#pragma once

#include <glad/glad.h>

namespace RenderEngine {
    /*!
    *  \brief Зачастую в играх разработчики хотят придавать объектам разные формы, а не только треугольные. Однако OpenGl уммет отрисовывать только треугольники, линии и точки. Божечки, дак что же делать? 
    Правильно, отрисовать так много треугольников, чтобы из них получилось что-то не треугольное. Например, чтобы вывести на экран квадрат достаточно нарисовать два треугольника. 
    Но чем больше треугольников мы рисуем, тем больше вершин нам придётся передавать в буферный объект (напомниаю, узнать что это можно в интернете, я итак много написал), а следовательно, в память.
    И самое страшное - эти вершини будут часто повторяться. К счастью, разработчики OpenGl создали для таких случаев Index Buffer Object - это буфер, вроде VBO, но он хранит индексы, которые OpenGL использует, 
    чтобы решить какую вершину отрисовать. Это называется отрисовка по индексам (indexed drawing) и является решением вышеуказанной проблемы. 

    Так в примере с квадратом нам потребуется хранить лишь 4 вершины, а не 6

    Так вот, этот класс как раз - таки и предназначен для создания этого буффера и работы с ним. Он будет необходим при рендере объектов.
    */
    class IndexBuffer {
    public:
        /*!
        *  Конструктор класса. В нём мы разве что зададим дефолтные значение полей id и elementsCount. Всё приравняем к нулю
        */
        IndexBuffer();
        /*!
        * Деструктор класса. Здесь мы удаляем буффер.
        */
        ~IndexBuffer();

        /*!
        * Запрещаем копирование класса в другой класс, так как у нас получатся два объекта с одним и тем же id и когда программа будет удаляться, выйдет казус неимоверный.
        */
        IndexBuffer(const IndexBuffer&) = delete;
        /*!
        * Запрещаем присваивание класса в другой класс, так как у нас получатся два объекта с одним и тем же id и когда программа будет удаляться, возникнет казус неимоверный.
        */
        IndexBuffer& operator=(const IndexBuffer&) = delete;
        /*!
         * Присваивать одному экземпляру класса другого, который скоро удалится, можно, так как не возникнет проблем с id, он будет уникальным.
         * Присваивает новому классу данные старого, а стрый класс очищает.
        */
        IndexBuffer& operator=(IndexBuffer&& indexBuffer) noexcept;
        /*!
         * Конструктор копирования объекта, который скоро удалится тоже разрешён, так как казусов с id буфера не возникнет
         * Присваивает новому классу данные старого, а стрый класс очищает.
        */
        IndexBuffer(IndexBuffer&& indexBuffer) noexcept;

        /*!
        * Создаём индексный буффер, привязываем его к объекту буффера и копируем индексы в буффер
        * \param data - индексы, которые мы хотим передать
        * \param elementsCount - количество индексов
        * \code
        *  this->elementsCount = elementsCount; //присваиваем нужное количество элементов в поле класса 
           glGenBuffers(1, &id); //Создаём индексный буффер
           glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, id); //Связываем его с объектом буффера (IBO с VBO)
           glBufferData(GL_ELEMENT_ARRAY_BUFFER, elementsCount * sizeof(GLuint), data, GL_STATIC_DRAW); //Копируем данные в объект буффера
        * \endcode
        */
        void InitializeBuffer(const void* data, const unsigned int elementsCount);

        /*!
        * Метод, связывающий данный индексный буффер с объектом буффера (IBO с VBO)
        */
        void BindBuffer() const;

        /*!
        * Метод, отвязывающий индексный буффер путём передачи ему нулевого индекса
        */
        void UnBindBuffer() const;
        
        /*!
        * Метод, возвращающий количество вершин-индексов.
        * \return elementsCount - количество вершин-индексов
        */
        unsigned int GetElementsCount() const
        {
            return elementsCount;
        }

    private:
        /*!
        * Идентификатор буффера
        */
        GLuint id;
        /*!
          * количество индексов в буффере
        */
        unsigned int elementsCount;
    };

}